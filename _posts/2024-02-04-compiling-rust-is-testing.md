---
layout: "post"
title: "Compiling Rust is testing"
date: "2024-02-04 16:13:00 +0100"
categories: rust
---

> Edit: it looks like some people misunderstood what I wanted to express with this post. So, to avoid further confusion, pretty much the only thing that I wanted to say here was this: I know that waiting for a Rust program to compile sucks, but we should not forget all the benefits that this compilation process brings us in return. (Yes, this post could have been a tweet).

This post is a very short contemplation of Rust compilation (times). Don't expect anything super insightful, just a bunch of thoughts that came up while I was listening to the [Rustacean Station](https://rustacean-station.org/episode/cliff-crosland/) podcast.

I'm currently analysing the results of the [Rust 2023 annual survey](https://blog.rust-lang.org/2023/12/18/survey-launch.html) (full results coming Soon™, hopefully sometime in February) and as usually, one of the most common complaints is long compilation time of Rust programs. This is certainly not a surprise, of course, as compilation times are often being cited as one of the biggest frustrations that people have with Rust.

As a member of the [Compiler performance working group](https://www.rust-lang.org/governance/teams/compiler#Compiler%20performance%20working%20group), I'm constantly on the lookout
for approaches that could improve the speed of the Rust compiler. Currently, there are exciting
things on the horizon, like the [parallel frontend](https://blog.rust-lang.org/2023/11/09/parallel-rustc.html) and the [Cranelift backend](https://github.com/rust-lang/rustc_codegen_cranelift?tab=readme-ov-file#download-using-rustup) now being available on `nightly`, and the `lld` linker [slowly moving](https://github.com/rust-lang/rust/issues/71515) to becoming the default linker on Linux. There are also [various]({% post_url 2023-10-21-make-rust-compiler-5percent-faster %}) [tricks](https://nnethercote.github.io/perf-book/build-configuration.html#minimizing-compile-times) that you can do to improve your compilation times on `stable` right now. However, these things will take time, and even once they are all implemented and even used by default, and even after we make a lot of other improvements to the compiler, some programmers will still consider Rust to be too slow to compile. And they're not wrong, since especially when compared to some other languages like Go or even Python, the compilation
speed of Rust might never be considered to be *fast enough* for all use-cases.

The codegen backend (LLVM), and sometimes the linker, is often being cited as a large source of slowness when compiling Rust, and truly so, since both can be bottlenecks. I'm personally putting a lot of hope into the Cranelift backend (or even a [Rust interpreter](https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/rustc_codegen_c/near/412964166)?) and faster linkers (`lld` or `mold`), to improve Rust's compilation speed.

However, it turns out that for cases that I consider to be latency-bound, where you want to perform the `make a change -> run tests` development loop as quickly as possible, using a non-optimized (`debug`) incremental build, the frontend of the compiler is often the true bottleneck (or, at the very least, it takes a non-trivial part of the compilation)[^fraction-chart]. Again, with the parallel frontend and other future improvements, this will get much better, but at the same time, there are some fundamental factors that just limit how fast the frontend can be. Be it general [design decisions](https://www.pingcap.com/blog/rust-compilation-model-calamity) that the language made a long time ago, or the determination of the compiler to provide exceptional error messages, which introduces a non-trivial performance cost even in the happy path where there are no errors.

[^fraction-chart]: We have recently started visualizing the ratio of time spent in frontend, backend and linker for all the Rust benchmarks that we execute. You can see it on the Perf.RLO [compare page](https://perf.rust-lang.org/compare.html), if you expand a row in the benchmark result table and take a look at the colourful horizontal bar chart labeled `Sections`.

While thinking about this, I realized something that I haven't explicitly thought about before, even though it's kind of obvious.
If you're used to e.g. Python, where you can make an incremental change and then rerun tests immediately, any compilation time might seem like pure overhead. In a way, I also had this mindset about Rust, since when I repeatedly perform the `make a change -> run tests` loop, I have considered the compilation time to just be a delay before I can run my tests again.

But there's also another way to look at this: **The compilation itself is a part of your test suite!** Since Rust can catch so many issues during compilation already, I think that it could be interesting to explicitly think about the compilation process being a first part of your overall test suite. Any interface (function signature, trait, variable type, …) being spelled out in the code is a mini unit test, and any compile error is said unit test failing. Notably, this also generalizes to the architecture of the program as a whole. Rust is notorious for guiding (sometimes even forcing) you towards certain architectural patterns, particularly around ownership of data, which can prevent annoying problems that could otherwise cause issues much later down the road. In a way, this could be seen as the compiler performing an integration test on your codebase during compiling, where it checks that the individual parts of your program compose together in a reasonable way.

Of course, this is not a new revelation by any means, as one of biggest cited advantages of Rust is that it helps with [shifting left](https://en.wikipedia.org/wiki/Shift-left_testing), i.e. moving many bugs from production (runtime) to development (compile time), and thus reducing the cost to fix said bugs. You could say that all languages that are statically typed and have a reasonable type system provide the same benefit. However, I would say that thanks to enums, pattern matching, ownership, [destructive move semantics](https://www.thecodedmessage.com/posts/cpp-move/), lifetimes and other features, Rust "executes many more tests" during compilation than any other "mainstream" programming language, so to speak.

Well, that's all that I wanted to express in this post. If you have any comments or thoughts, please let me know on [Reddit](https://www.reddit.com/r/rust/comments/1aiscx5/compiling_rust_is_testing/).
